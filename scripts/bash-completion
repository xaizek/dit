#!/bin/bash

complete -F _scribe scribe

# main completion function, dispatches command line and picks function that will
# generate real completion list
function _scribe()
{
    local cur="${COMP_WORDS[$COMP_CWORD]}"
    local args=( ${COMP_LINE:0:$COMP_POINT}::cursor:: )
    unset args[0]

    if [ "${COMP_LINE:$(( $COMP_POINT - 1 ))}" = '=' ]; then
        # try to fix issues related to use of = as a word separator (this is
        # a readline setting, which we can't control per command completion)
        cur=
    fi

    # obtain completion from the application
    local compl="$(scribe $project complete ${args[@]})"
    local IFS=$'\n'
    COMPREPLY=( $( compgen -W "$compl" -- "$cur" ) )

    # try to properly escape completion results
    # almost unchanged from from: http://stackoverflow.com/a/1146716/1535516
    local escaped_single_qoute="'\''"
    local i=0
    for entry in ${COMPREPLY[*]}
    do
        if [[ "${cur:0:1}" == "'" ]]; then
            # started with single quote, escaping only other single quotes
            # [']bla'bla"bla\bla bla --> [']bla'\''bla"bla\bla bla
            COMPREPLY[$i]="${entry//\'/${escaped_single_qoute}}"
        elif [[ "${cur:0:1}" == '"' ]]; then
            # started with double quote, escaping all double quotes and all
            # backslashes
            # ["]bla'bla"bla\bla bla --> ["]bla'bla\"bla\\bla bla
            entry="${entry//\\/\\\\}"
            COMPREPLY[$i]="${entry//\"/\\\"}"
        else
            # no quotes in front, escaping _everything_
            # [ ]bla'bla"bla\bla bla --> [ ]bla\'bla\"bla\\bla\ bla
            entry="${entry//\\/\\\\}"
            entry="${entry//\'/\'}"
            entry="${entry//\"/\\\"}"
            entry="${entry//|/\\|}"
            COMPREPLY[$i]="${entry// /\\ }"
        fi
        (( i++ ))
    done
}
